<!DOCTYPE html>
<html lang="ko-KR">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width">
    <title>eventDefault</title>
    <link rel="stylesheet" href="css/font.css">
    <link rel="stylesheet" href="css/prism.css">
    <link rel="stylesheet" href="css/tab.css">
    <link rel="stylesheet" href="css/child_style.css">
    <!--[if lt IE 9]>
    <style>
        code{overflow: auto}
    </style>
    <![endif]-->
</head>
<body>
<div id="wrap">
    <div class="explain">
        <h1 class="tit">객체 리터럴</h1>
        <dl>
            <dt class="d_tit">객체 리터럴</dt>
            <dd class="d_txt">
                객체 리터럴에는 편리한 기능들이 추가되었습니다.
                <pre class="line-numbers">
                    <code class="language-javascript">
                        var sayNode = function () {
                            console.log('Node');
                        };
                        var es = 'ES';
                        var oldObject = {
                            sayJS: function () {
                                console.log('JS');
                            },
                            sayNode: sayNode,
                        };
                        oldObject[es + 6] = 'Fantastic';

                        oldObject.sayNode(); // Node
                        oldObject.sayJS(); // JS
                        console.log(oldObject.ES6); // Fantastic
                    </code>
                </pre>
                oldObject 객체에 동적으로 속성을 추가하고 있습니다. <br>
                앞의 코드를 다음과 같이 다시 쓸 수 있습니다.
                <pre class="line-numbers">
                    <code class="language-javascript">
                        var sayNode = function () {
                            console.log('Node');
                        };
                        var es = 'ES';

                        const newObject = {
                            sayJS() {
                                console.log('JS');
                            },
                            sayNode,
                            [es + 6]: 'Fantastic',
                        };
                        newObject.sayNode(); // Node
                        newObject.sayJS(); // JS
                        console.log(newObject.ES6); // Fantastic
                    </code>
                </pre>
                Object와 newObject를 비교해서 보면 됩니다. <br>
                sayJS 같은 객체의 메서드에 함수를 연결할 때 더는 콜론(:)과 function을 붙이지 않아도 됩니다. <br>
                <br>
                <strong>sayNode: sayNode</strong> 처럼 속성명과 변수명이 겹치는 경우에는 한 번만 쓸 수 있게 되었습니다. <br>
                자바스크립트에서 다음과 같은 경우가 많이 나오는데, 이때 코드의 중복을 피할 수 있어 편리합니다.
                <pre class="line-numbers">
                    <code class="language-javascript">
                        { name: name, age: age } // ES5
                        { name, age } // ES2015
                    </code>
                </pre>
                객체의 속성명을 동적으로 생성할 수 있습니다. <br>
                예쩐 문법에서는 ES6라는 속성명을 만들려면 객체 리터럴(oldObject) 바깥에서 [es + 6]을 해야 했습니다. <br>
                하지만 ES2015 문법에서는 객체 리터럴 안에 선언해도 됩니다.
                <p class="e_comment">
                    ## Note <br>
                    컴퓨터 과학 분야에서 리터럴(literal)이란 소스 코드의 고정된 값을 대표하는 용어다. <br>
                    Literal Constant, 리터럴 상수, String Literal, 문자열 리터럴, String Constant, 문자열 상수, Object Literal, 객체 리터럴
                </p>
                newObject 안에서 [es + 6]가 속성명으로 바로 사용되고 있습니다. <br>
                <br>
                객체 리터럴에 추가된 문법은 코딩시 편의를 위해 만들어진 것이라는 느낌이 강합니다. <br>
                익숙해지면 코드의 양을 많이 줄일 수 있습니다.

            </dd>
        </dl>
    </div>
</div>

<script src="js/prism.js"></script>
<script src="js/tab.js"></script>
</body>
</html>